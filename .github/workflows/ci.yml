name: CI

on:
  push:
    branches: [ main, master ]
    tags:
      - 'v*'
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      promote_prod:
        description: 'Deploy to production (bypass tag)'
        type: boolean
        default: false

jobs:
  test:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      - name: Install deps (if any)
        run: |
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi

      - name: Prime workspace artifact for quick_contract
        env:
          SEARCH_PROVIDER: dummy
        run: |
          python - <<'PY'
          import io, base64, zipfile, sys
          from pathlib import Path
          sys.path.insert(0, str(Path(".").resolve()))
          from jobs.worker import process_job
          Path("workspace").mkdir(exist_ok=True)
          resp = process_job({"job_name":"core","args":{"topic":"CI prime","n":2,"enable_research":True,"search_max":2,"fetch_max":0,"n_per_claim":1}})
          arts = resp.get("artifacts", [])
          if arts:
              data = base64.b64decode(arts[0].get("base64",""))
              with zipfile.ZipFile(io.BytesIO(data)) as z:
                  z.extractall("workspace")
              print("Primed workspace with artifact contents.")
          else:
              print("No artifacts produced; continuing anyway.")
          PY

      - name: Show workspace listing
        run: |
          echo "--- workspace tree ---"
          find workspace -maxdepth 2 -type f -print || true

      - name: Run contract tests + smoke
        env:
          SEARCH_PROVIDER: dummy
        run: |
          python tests/run_all.py

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cerberus-tests
          path: |
            workspace/**
            contract_artifact_*.zip
            cerberus_core--RID-*.zip
            **/contract_artifact_*.zip
            **/cerberus_core--RID-*.zip

  deploy-staging:
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Check required environment vars
        run: |
          echo "FLY_APP_NAME=${{ vars.FLY_APP_NAME }}"
          echo "FLY_PRIMARY_REGION=${{ vars.FLY_PRIMARY_REGION }}"
          if [ -z "${{ vars.FLY_APP_NAME }}" ]; then
            echo "::error::Set FLY_APP_NAME in the 'staging' environment."
            exit 1
          fi

      - name: Configure Fly secrets (staging)
        env:
          FLYCTL_AUTH_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl secrets set \
            CERBERUS_API_KEY='${{ secrets.CERBERUS_API_KEY }}' \
            GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY }}' \
            REQUIRE_TIMESTAMP='${{ secrets.REQUIRE_TIMESTAMP }}' \
            --app '${{ vars.FLY_APP_NAME }}'

      - name: Deploy to Fly (staging)
        env:
          FLYCTL_AUTH_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl deploy --remote-only --app '${{ vars.FLY_APP_NAME }}'

      - name: Smoke: /healthz (verbose)
        run: |
          URL="https://${{ vars.FLY_APP_NAME }}.fly.dev/healthz"
          echo "GET $URL"
          (curl -sv "$URL" -o healthz.json -w "\nHTTP %{http_code}\n") 2>curl_healthz.debug || true
          cat healthz.json || true

      - name: Smoke: /jobs/run (verbose)
        env:
          API_KEY: ${{ secrets.CERBERUS_API_KEY }}
        run: |
          TS=$(date +%s)
          cat > body.json <<JSON
          {"job_name":"core","args":{"topic":"CI smoke","n":3,"enable_research":true,"search_max":6,"fetch_max":0,"n_per_claim":1,"timestamp":$TS}}
          JSON
          URL="https://${{ vars.FLY_APP_NAME }}.fly.dev/jobs/run"
          echo "POST $URL"
          (curl -sv -X POST "$URL" \
             -H "content-type: application/json" \
             -H "X-API-Key: ${API_KEY}" \
             --data-binary @body.json \
             -o job.json -w "\nHTTP %{http_code}\n") 2>curl_job.debug || true
          head -c 2000 job.json || true

      - name: Upload smoke artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: cerberus-staging-smoke
          path: |
            healthz.json
            job.json
            body.json
            curl_healthz.debug
            curl_job.debug

  deploy-prod:
    needs: deploy-staging
    if: startsWith(github.ref, 'refs/tags/v') || (github.event_name == 'workflow_dispatch' && inputs.promote_prod == 'true')
    runs-on: ubuntu-latest
    environment: production
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Flyctl
        uses: superfly/flyctl-actions/setup-flyctl@master

      - name: Check required environment vars
        run: |
          echo "FLY_APP_NAME=${{ vars.FLY_APP_NAME }}"
          if [ -z "${{ vars.FLY_APP_NAME }}" ]; then
            echo "::error::Set FLY_APP_NAME in the 'production' environment."
            exit 1
          fi

      - name: Configure Fly secrets (prod)
        env:
          FLYCTL_AUTH_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl secrets set \
            CERBERUS_API_KEY='${{ secrets.CERBERUS_API_KEY }}' \
            GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY }}' \
            REQUIRE_TIMESTAMP='${{ secrets.REQUIRE_TIMESTAMP }}' \
            --app '${{ vars.FLY_APP_NAME }}'

      - name: Deploy to Fly (prod)
        env:
          FLYCTL_AUTH_TOKEN: ${{ secrets.FLY_API_TOKEN }}
        run: |
          flyctl deploy --remote-only --app '${{ vars.FLY_APP_NAME }}'
